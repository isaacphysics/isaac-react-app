import React, {lazy, Suspense, useCallback, useEffect, useMemo, useReducer, useState} from "react";
import {
    AppState,
    clearQuestionSearch,
    closeActiveModal,
    searchQuestions,
    useAppDispatch,
    useAppSelector
} from "../../../state";
import debounce from "lodash/debounce";
import isEqual from "lodash/isEqual";
import {MultiValue} from "react-select";
import {
    tags,
    DIFFICULTY_ICON_ITEM_OPTIONS,
    EXAM_BOARD_NULL_OPTIONS,
    getFilteredExamBoardOptions,
    getFilteredStageOptions,
    groupTagSelectionsByParent,
    isAda,
    isPhy,
    isStaff,
    Item,
    logEvent,
    searchResultIsPublic,
    selectOnChange,
    siteSpecific,
    SortOrder,
    sortQuestions,
    STAGE,
    useUserViewingContext,
    ISAAC_BOOKS,
    TAG_LEVEL,
    below,
    useDeviceSize
} from "../../../services";
import {ContentSummary, GameboardBuilderQuestions, GameboardBuilderQuestionsStackProps} from "../../../../IsaacAppTypes";
import {AudienceContext, Difficulty, ExamBoard} from "../../../../IsaacApiTypes";
import {GroupBase} from "react-select/dist/declarations/src/types";
import {Loading} from "../../handlers/IsaacSpinner";
import {StyledSelect} from "../inputs/StyledSelect";
import { SortItemHeader } from "../SortableItemHeader";
import { Input, Row, Col, Label, Form, Table } from "reactstrap";
import classNames from "classnames";
import { HierarchyFilterTreeList } from "../svg/HierarchyFilter";
import { ChoiceTree, getChoiceTreeLeaves } from "../panels/QuestionFinderFilterPanel";
import { CollapsibleList } from "../CollapsibleList";
import { StyledCheckbox } from "../inputs/StyledCheckbox";
import { updateTopicChoices, initialiseListState, listStateReducer } from "../../../services";

// Immediately load GameboardBuilderRow, but allow splitting
const importGameboardBuilderRow = import("../GameboardBuilderRow");
const GameboardBuilderRow = lazy(() => importGameboardBuilderRow);

const selectStyle = {
    className: "basic-multi-select", classNamePrefix: "select",
    menuPortalTarget: document.body, styles: {menuPortal: (base: object) => ({...base, zIndex: 9999})}
};

interface QuestionSearchModalProps {
    currentQuestions: GameboardBuilderQuestions;
    undoStack: GameboardBuilderQuestionsStackProps;
    redoStack: GameboardBuilderQuestionsStackProps;
    eventLog: object[];
}
export const QuestionSearchModal = (
    {currentQuestions, undoStack, redoStack, eventLog}: QuestionSearchModalProps) => {
    const dispatch = useAppDispatch();
    const userContext = useUserViewingContext();
    const deviceSize = useDeviceSize();
    const sublistDelimiter = " >>> ";

    const [topicSelections, setTopicSelections] = useState<ChoiceTree[]>([]);
    const [searchTopics, setSearchTopics] = useState<string[]>([]);
    const [searchQuestionName, setSearchQuestionName] = useState("");
    const [searchStages, setSearchStages] = useState<STAGE[]>([]);
    const [searchDifficulties, setSearchDifficulties] = useState<Difficulty[]>([]);
    const [searchExamBoards, setSearchExamBoards] = useState<ExamBoard[]>([]);
    useEffect(function populateExamBoardFromUserContext() {
        if (!EXAM_BOARD_NULL_OPTIONS.includes(userContext.examBoard)) setSearchExamBoards([userContext.examBoard]);
    }, [userContext.examBoard]);

    const [isSearching, setIsSearching] = useState(false);
    const [searchBook, setSearchBook] = useState<string[]>([]);
    const isBookSearch = searchBook.length > 0;

    const creationContext: AudienceContext = useMemo(() => !isBookSearch ? {
        stage: searchStages.length > 0 ? searchStages : undefined,
        difficulty: searchDifficulties.length > 0 ? searchDifficulties : undefined,
        examBoard: searchExamBoards.length > 0 ? searchExamBoards : undefined,
    } : {}, [isBookSearch, searchStages, searchDifficulties, searchExamBoards]);

    const [searchFastTrack, setSearchFastTrack] = useState<boolean>(false);

    const [questionsSort, setQuestionsSort] = useState<Record<string, SortOrder>>({});
    const [selectedQuestions, setSelectedQuestions] = useState<Map<string, ContentSummary>>(new Map(currentQuestions.selectedQuestions));
    const [questionOrder, setQuestionOrder] = useState([...currentQuestions.questionOrder]);

    const modalQuestions : GameboardBuilderQuestions = {selectedQuestions, questionOrder, setSelectedQuestions, setQuestionOrder};

    const {results: questions} = useAppSelector((state: AppState) => state && state.questionSearchResult) || {};
    const user = useAppSelector((state: AppState) => state && state.user);

    useEffect(() => {
        setIsSearching(false);
    }, [questions]);

    const searchDebounce = useCallback(
        debounce((searchString: string, topics: string[], examBoards: string[], book: string[], stages: string[], difficulties: string[], fasttrack: boolean, startIndex: number) => {
            // Clear front-end sorting so as not to override ElasticSearch's match ranking
            setQuestionsSort({});

            const isBookSearch = book.length > 0; // Tasty.
            if ([searchString, topics, book, stages, difficulties, examBoards].every(v => v.length === 0) && !fasttrack) {
                // Nothing to search for
                dispatch(clearQuestionSearch);
                return;
            }

            const tags = (isBookSearch ? book : [...([topics].map((tags) => tags.join(" ")))].filter((query) => query != "")).join(",");

            setIsSearching(true);

            dispatch(searchQuestions({
                querySource: "gameboardBuilder",
                searchString: searchString || undefined,
                tags: tags || undefined,
                stages: stages.join(",") || undefined,
                difficulties: difficulties.join(",") || undefined,
                examBoards: examBoards.join(",") || undefined,
                fasttrack,
                startIndex,
                limit: 300
            }));

            logEvent(eventLog,"SEARCH_QUESTIONS", {searchString, topics, examBoards, book, stages, difficulties, fasttrack, startIndex});
        }, 250),
        []
    );

    const sortableTableHeaderUpdateState = (sortState: Record<string, SortOrder>, setSortState: React.Dispatch<React.SetStateAction<Record<string, SortOrder>>>, key: string) => (order: SortOrder) => {
        const newSortState = {...sortState};
        newSortState[key] = order;
        setSortState(newSortState);
    };

    const tagOptions: { options: Item<string>[]; label: string }[] = isPhy ? tags.allTags.map(groupTagSelectionsByParent) : tags.allSubcategoryTags.map(groupTagSelectionsByParent);
    const groupBaseTagOptions: GroupBase<Item<string>>[] = tagOptions;
    const [listState, listStateDispatch] = useReducer(listStateReducer, groupBaseTagOptions, initialiseListState);

    useEffect(() => {
        searchDebounce(searchQuestionName, searchTopics, searchExamBoards, searchBook, searchStages, searchDifficulties, searchFastTrack, 0);
    },[searchDebounce, searchQuestionName, searchTopics, searchExamBoards, searchBook, searchFastTrack, searchStages, searchDifficulties]);

    const sortedQuestions = useMemo(() => {
        return questions && sortQuestions(isBookSearch ? {title: SortOrder.ASC} : questionsSort, creationContext)(
            questions.filter(question => {
                const qIsPublic = searchResultIsPublic(question, user);
                if (isBookSearch) return qIsPublic;
                const qTopicsMatch =
                    searchTopics.length === 0 ||
                    (question.tags && question.tags.filter((tag) => searchTopics.includes(tag)).length > 0);

                return qIsPublic && qTopicsMatch;
            })
        );
    }, [questions, user, searchTopics, isBookSearch, questionsSort, creationContext]);

    const addSelectionsRow = <div className="d-sm-flex flex-xl-column align-items-center">
        <div className="flex-grow-1 mb-1">
            <strong className={selectedQuestions.size > 10 ? "text-danger" : ""}>
                {siteSpecific(
                    `${selectedQuestions.size} Question${selectedQuestions.size !== 1 ? "s" : ""} Selected`,
                    `${selectedQuestions.size} question${selectedQuestions.size !== 1 ? "s" : ""} selected`
                )}
            </strong>
        </div>
        <div>
            <Input
                type="button"
                value={siteSpecific("Add selections to question deck", "Add selections to quiz")}
                disabled={isEqual(new Set(modalQuestions.selectedQuestions.keys()), new Set(currentQuestions.selectedQuestions.keys()))}
                className={classNames("btn w-100 h-100", siteSpecific("btn-keyline", "btn-solid border-0"))}
                onClick={() => {
                    undoStack.push({questionOrder: currentQuestions.questionOrder, selectedQuestions: currentQuestions.selectedQuestions});
                    currentQuestions.setSelectedQuestions(modalQuestions.selectedQuestions);
                    currentQuestions.setQuestionOrder(modalQuestions.questionOrder);
                    redoStack.clear();
                    dispatch(closeActiveModal());
                }}
            />
        </div>
    </div>;

    const topicChoices = useMemo(() => {
        return updateTopicChoices(topicSelections);
    }, [topicSelections]);

    // The (phy) hierarchy filter uses a ChoiceTree, but the search endpoint needs a string
    useEffect(() => {
        setSearchTopics(getChoiceTreeLeaves(topicSelections).map((s) => s.value));
    }, [topicSelections]);

    return <Row>
        <Col className="col-12 col-xl-3 mt-4">
            <Row>
                <Col className={isPhy && !isBookSearch ? "col-12 col-lg-6 col-xl-12" : ""}>
                    {isAda && <CollapsibleList title={<span className="ms-n3">Topic</span>} expanded={listState.topics.state} className="mb-3"
                        toggle={() => listStateDispatch({type: "toggle", id: "topics", focus: below["md"](deviceSize)})}>
                        {groupBaseTagOptions.map((tag, index) => (
                            <li key={index} style={{listStyle: "none"}}>
                                <CollapsibleList title={tag.label} asSubList
                                    expanded={listState[`topics ${sublistDelimiter} ${tag.label}`]?.state}
                                    toggle={() => listStateDispatch({type: "toggle", id: `topics ${sublistDelimiter} ${tag.label}`, focus: true})}>
                                    {tag.options.map((topic, index) => (
                                        <li className={classNames("w-100 ps-3 py-1", {"bg-white": isAda})} style={{listStyle: "none"}} key={index}>
                                            <StyledCheckbox color="primary" checked={searchTopics.includes(topic.value)}
                                                onChange={() => setSearchTopics(s => s.includes(topic.value) ? s.filter(v => v !== topic.value) : [...s, topic.value])}
                                                label={<span>{topic.label}</span>} className="ps-3"/>
                                        </li>))}
                                </CollapsibleList>
                            </li>))}
                    </CollapsibleList>}
                    {isPhy && <div className="mb-2">
                        <Label htmlFor="question-search-book">Book</Label>
                        <StyledSelect
                            inputId="question-search-book" isClearable placeholder="None" {...selectStyle}
                            onChange={(e) => {
                                selectOnChange(setSearchBook, true)(e);
                                sortableTableHeaderUpdateState(questionsSort, setQuestionsSort, "title");
                            }}
                            options={ISAAC_BOOKS.filter(b => !b.hidden).map(book => ({value: book.tag, label: book.shortTitle}))}
                        />
                    </div>}
                    <div className={`mb-2 ${isBookSearch ? "d-none" : ""}`}>
                        <Label htmlFor="question-search-stage">Stage</Label>
                        <StyledSelect
                            inputId="question-search-stage" isClearable isMulti placeholder="Any" {...selectStyle}
                            options={getFilteredStageOptions()} onChange={selectOnChange(setSearchStages, true)}
                        />
                    </div>
                    {isPhy && !isBookSearch && deviceSize !== "lg" && <div className="mb-2">
                        <Label htmlFor="question-search-topic">Topic</Label>
                        <HierarchyFilterTreeList root {...{
                            inputId: "question-search-topic", tier: 0, index: TAG_LEVEL.subject,
                            choices: topicChoices, selections: topicSelections, setSelections: setTopicSelections}}/>
                    </div>}
                    <div className={`mb-2 ${isBookSearch ? "d-none" : ""}`}>
                        <Label htmlFor="question-search-difficulty">Difficulty</Label>
                        <StyledSelect
                            inputId="question-search-difficulty" isClearable isMulti placeholder="Any" {...selectStyle}
                            options={DIFFICULTY_ICON_ITEM_OPTIONS} onChange={selectOnChange(setSearchDifficulties, true)}
                        />
                        {isAda && <>
                            <Label htmlFor="question-search-exam-board">Exam Board</Label>
                            <StyledSelect
                                inputId="question-search-exam-board" isClearable isMulti placeholder="Any" {...selectStyle}
                                value={getFilteredExamBoardOptions({byStages: searchStages}).filter(o => searchExamBoards.includes(o.value))}
                                options={getFilteredExamBoardOptions({byStages: searchStages})}
                                onChange={(s: MultiValue<Item<ExamBoard>>) => selectOnChange(setSearchExamBoards, true)(s)}
                            />
                        </>}
                    </div>
                    <Label htmlFor="question-search-title">Search</Label>
                    <Input id="question-search-title" className="mb-2"
                        type="text"
                        placeholder={siteSpecific("e.g. Man vs. Horse", "e.g. Creating an AST")}
                        onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                            setSearchQuestionName(e.target.value);
                        }}
                    />
                    {isPhy && isStaff(user) &&
                        <Form className="mb-2">
                            <Label check><input type="checkbox" checked={searchFastTrack} onChange={e => setSearchFastTrack(e.target.checked)} />{' '}Show FastTrack questions</Label>
                        </Form>}
                </Col>
                {isPhy && !isBookSearch && deviceSize === "lg" && <Col className="col-6">
                    <Label htmlFor="question-search-topic">Topic</Label>
                    <HierarchyFilterTreeList root {...{
                        inputId: "question-search-topic", tier: 0, index: TAG_LEVEL.subject,
                        choices: topicChoices, selections: topicSelections, setSelections: setTopicSelections}}/>
                </Col>}
            </Row>
            {addSelectionsRow}
        </Col>
        <Col className="col-12 col-xl-9">
            <Suspense fallback={<Loading/>}>
                <Table bordered responsive className="mt-4">
                    <thead>
                        <tr className="search-modal-table-header">
                            <th className="w-5"> </th>
                            <SortItemHeader<SortOrder>
                                className={siteSpecific("w-40", "w-30")}
                                setOrder={sortableTableHeaderUpdateState(questionsSort, setQuestionsSort, "title")}
                                defaultOrder={SortOrder.ASC}
                                reverseOrder={SortOrder.DESC}
                                currentOrder={questionsSort['title']}
                                alignment="start"
                            >Question title</SortItemHeader>
                            <th className={siteSpecific("w-25", "w-20")}>Topic</th>
                            <th className="w-15">Stage</th>
                            <th className="w-15">Difficulty</th>
                            {isAda && <th className="w-15">Exam boards</th>}
                        </tr>
                    </thead>
                    <tbody>
                        {isSearching ? <tr><td colSpan={isAda ? 6 : 5}><Loading/></td></tr> : sortedQuestions?.map(question =>
                            <GameboardBuilderRow
                                key={`question-search-modal-row-${question.id}`}
                                question={question}
                                currentQuestions={modalQuestions}
                                undoStack={undoStack}
                                redoStack={redoStack}
                                creationContext={creationContext}
                            />
                        )}
                    </tbody>
                </Table>
            </Suspense>
        </Col>
    </Row>;
};
