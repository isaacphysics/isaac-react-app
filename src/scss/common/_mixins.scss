// Helper for playing with pseudo element
// $width: width of the pseudo element.
// $height: height of the pseudo element.
// $content: when playing with pseudo element, you mainly use `content: ""` (default value).
// $position: when playing with pseudo element, you mainly use `position: absolute` (default value).
// $display: when playing with pseudo element, you mainly use `display: block` (default value).
@use "sass:math";
@use "sass:color";

@mixin pseudo-element($content: '', $position: absolute, $display: block) {
  content: $content;
  display: $display;
  position: $position;
}
// Detect IE10 and IE11
@mixin ie() {
  @media screen and (-ms-high-contrast: active),
  screen and (-ms-high-contrast: none) {
    @content;
  }
}
//
//  MEDIA QUERIES
//––––––––––––––––––––––––––––––––––––––––––––––––––
// A map of breakpoints.
// /!\ WARNING /!\ this is not the same as bootstraps $grid-breakpoints! (although it really should be!!!)
$breakpoints: (
        xs: 576px,
        sm: 768px,
        md: 992px,
        lg: 1200px,
        nav: 1256px
); //
//  RESPOND ABOVE
//––––––––––––––––––––––––––––––––––––––––––––––––––
// @include respond-above(sm) {}
@mixin respond-above($breakpoint) {
  // If the breakpoint exists in the map.
  @if map-has-key($breakpoints, $breakpoint) {
    // Get the breakpoint value.
    $breakpoint-value: map-get($breakpoints, $breakpoint);
    // Write the media query.
    @media (min-width: $breakpoint-value) {
      @content;
    }
    // If the breakpoint doesn't exist in the map.
  } @else {
    // Log a warning.
    @warn 'Invalid breakpoint: #{$breakpoint}.';
  }
}
//
//  RESPOND BELOW
//––––––––––––––––––––––––––––––––––––––––––––––––––
// @include respond-below(sm) {}
@mixin respond-below($breakpoint) {
  // If the breakpoint exists in the map.
  @if map-has-key($breakpoints, $breakpoint) {
    // Get the breakpoint value.
    $breakpoint-value: map-get($breakpoints, $breakpoint);
    // Write the media query.
    @media (max-width: ($breakpoint-value - 1)) {
      @content;
    }
    // If the breakpoint doesn't exist in the map.
  } @else {
    // Log a warning.
    @warn 'Invalid breakpoint: #{$breakpoint}.';
  }
}
//
//  RESPOND BETWEEN
//––––––––––––––––––––––––––––––––––––––––––––––––––
// @include respond-between(sm, md) {}
@mixin respond-between($lower, $upper) {
  // If both the lower and upper breakpoints exist in the map.
  @if map-has-key($breakpoints, $lower) and map-has-key($breakpoints, $upper) {
    // Get the lower and upper breakpoints.
    $lower-breakpoint: map-get($breakpoints, $lower);
    $upper-breakpoint: map-get($breakpoints, $upper);
    // Write the media query.
    @media (min-width: $lower-breakpoint) and (max-width: ($upper-breakpoint - 1)) {
      @content;
    }
    // If one or both of the breakpoints don't exist.
  } @else {
    // If lower breakpoint is invalid.
    @if (map-has-key($breakpoints, $lower) == false) {
      // Log a warning.
      @warn 'Your lower breakpoint was invalid: #{$lower}.';
    }
    // If upper breakpoint is invalid.
    @if (map-has-key($breakpoints, $upper) == false) {
      // Log a warning.
      @warn 'Your upper breakpoint was invalid: #{$upper}.';
    }
  }
}
// outline helper
@mixin out($colour: pink, $width: 1px) {
  outline: $width solid $colour;
}
@mixin placeholder($colour: pink) {
  /* Chrome, Firefox, Opera, Safari 10.1+ */
  &::placeholder {
    color: $colour !important;
    /* Firefox */
    opacity: 1;
  }
  /* Some older WebKit based browsers */
  &::-webkit-input-placeholder {
    color: $colour !important;
    opacity: 1;
  }
  /* Internet Explorer 10-11 */
  &:-ms-input-placeholder {
    color: $colour !important;
  }
  /* Microsoft Edge */
  &::-ms-input-placeholder {
    color: $colour !important;
  }
}

$viewport-sizes: (
  25: 25%,
  50: 50%,
  75: 75%,
  100: 100%,
  auto: auto,
);

// Size / viewports -- (correctly) uses Bootstrap's breakpoints, NOT the ones declared in this file
@each $bp, $bp-width in map-remove($grid-breakpoints, xs) {
  @media (min-width: $bp-width) {
    @each $size, $size-value in $viewport-sizes {
      .w-#{$bp}-#{$size} {
        width: #{$size-value} !important;
      }
      .h-#{$bp}-#{$size} {
        height: #{$size-value} !important;
      }
    }
  }
}

// Fixed sizes
@for $size from 1 through 20 {
  .wf-#{$size} {
    width: #{$size}rem !important;
  }
  .hf-#{$size} {
    height: #{$size}rem !important;
  }
}

.mw-auto {
  min-width: auto !important;
}

@mixin aspect-ratio($width, $height) {
  aspect-ratio: calc($width / $height);
}

@mixin svg-icon-raw($path, $width, $height, $background-size: none, $background-position: none) {
  // use this only for SVG icons that should not be recoloured; prefer @svg-icon in general
  display: inline-block;
  background: url($path) center center no-repeat;
  width: $width;
  height: $height;
  min-width: $width;
  min-height: $height;
  @if $background-size != none {
    background-size: $background-size;
  }
  @if $background-position != none {
    background-position: $background-position;
  }
}

@mixin svg-icon($path, $width: 16px, $height: 16px, $mask-size: none, $mask-position: none) {
  display: inline-block;
  width: $width;
  height: $height;
  min-width: $width;
  min-height: $height;
  background-color: black; // this has to be here, not inside the @supports, as that raises the specificity beyond that of background colours specified alongside @include svg-icon

  @supports (mask: url($path) center center no-repeat) {
    mask: url($path) center center no-repeat;
    @if $mask-size != none {
      mask-size: $mask-size;
    }
    @if $mask-position != none {
      mask-position: $mask-position;
    }
  }

  @supports not (mask: url($path) center center no-repeat) {
    // TODO this had to be shorthand format to correctly override all background props, surely can simplify though
    @if $mask-size != none {
      @if $mask-position != none {
        background: url($path) $mask-position/$mask-size no-repeat !important;
      } @else {
        background: url($path) center center/$mask-size no-repeat !important;
      }
    } @else {
      @if $mask-position != none {
        background: url($path) $mask-position no-repeat !important;
      } @else {
        background: url($path) center center no-repeat !important;
      }
    }
  }
}

@mixin svg-icon-layered($fg_path, $bg_path, $width: 16px, $height: 16px, $mask-size: 100%, $mask-position: none) {
  --layered-icon-parent-bg-override: transparent;
  display: inline-flex;
  width: $width;
  height: $height;
  min-width: $width;
  min-height: $height;
  &::before {
    content: '';
    @include svg-icon($bg_path, $width, $height, $mask-size, $mask-position);
    position: absolute;
  }
  &::after {
    content: '';
    @include svg-icon($fg_path, $width, $height, $mask-size, $mask-position);
    position: absolute;
  }
}

@mixin svg-color($image, $color, $width, $height, $mask-size: none, $mask-position: none) {
  width: $width;
  height: $height;
  min-width: $width;
  min-height: $height;

  @supports (mask: $image center center no-repeat) {
    mask: $image no-repeat center center;
    background-color: $color;
    @if $mask-size != none {
      mask-size: $mask-size;
    }
    @if $mask-position != none {
      mask-position: $mask-position;
    }
  }

  @supports not (mask: $image center center no-repeat) {
    @if $mask-size != none {
      @if $mask-position != none {
        background: $image $mask-position/$mask-size no-repeat !important;
      } @else {
        background: $image center center/$mask-size no-repeat !important;
      }
    } @else {
      @if $mask-position != none {
        background: $image $mask-position no-repeat !important;
      } @else {
        background: $image center center no-repeat !important;
      }
    }
  }
}

@mixin pseudo-icon($path, $width: 16px, $height: 16px, $mask-size: none, $mask-position: none) {
  content: "";
  position: relative;
  @include svg-icon($path, $width, $height, $mask-size, $mask-position);
}

@mixin icon-color-override($color) {
  // only do this if masks are supported
  @supports (mask-position: center) {
    background-color: var(--layered-icon-parent-bg-override, $color) !important;

    &::before {
      background-color: $color !important;
    }
    &::after {
      background-color: $color !important;
    }
  }
}

// modified from https://css-tricks.com/books/greatest-css-tricks/scroll-shadows/
@mixin vertical-scroll-shadow($background-color: white, $shadow-color: rgba(0, 0, 0, 0.2)) {
  background:
    linear-gradient(
      $background-color 30%,
      color.change($background-color, $alpha: 0)
    ) center top,
    
    linear-gradient(
      color.change($background-color, $alpha: 0),
      $background-color 70%
    ) center bottom,

    radial-gradient(
      farthest-side at 50% 0,
      $shadow-color,
      color.change($shadow-color, $alpha: 0)
    ) center top,

    radial-gradient(
      farthest-side at 50% 100%,
      $shadow-color,
      color.change($shadow-color, $alpha: 0)
    ) center bottom;

  background-repeat: no-repeat;
  background-size: 100% 40px, 100% 40px, 100% 14px, 100% 14px;
  background-attachment: local, local, scroll, scroll;
}

@mixin horizontal-scroll-shadow($background-color: white, $shadow-color: rgba(0, 0, 0, 0.2)) {
  background:
    linear-gradient(
      to right,
      $background-color 30%,
      color.change($background-color, $alpha: 0)
    ) left center,
    
    linear-gradient(
      to right,
      color.change($background-color, $alpha: 0),
      $background-color 70%
    ) right center,

    radial-gradient(
      farthest-side at 0 50%,
      $shadow-color,
      color.change($shadow-color, $alpha: 0)
    ) left center,

    radial-gradient(
      farthest-side at 100% 50%,
      $shadow-color,
      color.change($shadow-color, $alpha: 0)
    ) right center;

  background-repeat: no-repeat;
  background-size: 40px 100%, 40px 100%, 14px 100%, 14px 100%;
  background-attachment: local, local, scroll, scroll;
}

@mixin no-print {
  @media not print {
    @content;
  }
}

@mixin only-print {
  @media print {
    @content;
  }
}

@mixin table-sticky() {
  position: sticky !important;
  position: -webkit-sticky !important;
  background-clip:  padding-box !important;
  z-index: 2;
}

@mixin fixed-text-height($line-height: 1.5rem, $lines: 2) {
  max-height: calc(#{$line-height} * #{$lines});
  overflow: hidden;
  display: -webkit-box !important;
  -webkit-line-clamp: $lines;
  line-clamp: 2;
  -webkit-box-orient: vertical;
}
